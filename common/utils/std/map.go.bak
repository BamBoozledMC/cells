/*
 * Copyright (c) 2018. Abstrium SAS <team (at) pydio.com>
 * This file is part of Pydio Cells.
 *
 * Pydio Cells is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Pydio Cells is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with Pydio Cells.  If not, see <http://www.gnu.org/licenses/>.
 *
 * The latest code can be found at <https://pydio.com>.
 */

package std

import (
	"bytes"
	"encoding/json"
	"strconv"
	"strings"

	"github.com/golang/protobuf/jsonpb"
	"github.com/golang/protobuf/proto"
	"github.com/spf13/cast"

	"github.com/pydio/cells/common"
)

// Map structure to store configuration
type Map map[string]interface{}

// NewMap variable
func NewMap(ms ...map[string]interface{}) *Map {
	if len(ms) > 0 {
		m := new(Map)
		*m = ms[0]
		return m
	}
	return &Map{}
}

func keysToString(k ...common.Key) []string {
	var r []string

	for _, kk := range k {
		switch v := kk.(type) {
		case int:
			r = append(r, strconv.Itoa(v))
		case string:
			v = strings.Replace(v, "[", "/", -1)
			v = strings.Replace(v, "]", "/", -1)
			v = strings.Replace(v, "//", "/", -1)
			v = strings.Trim(v, "/")
			r = append(r, strings.Split(v, "/")...)
		case []string:
			for _, vv := range v {
				r = append(r, keysToString(vv)...)
			}
		}
	}

	return r
}

func (c Map) Get() interface{} {
	return c
}

func (c Map) Set(data interface{}) error {

	switch v := data.(type) {
	case []byte:
		return json.Unmarshal(v, &c)
	case map[string]interface{}:
		for k := range c {
			delete(c, k)
		}
		for k, vv := range v {
			c[k] = vv
		}
	}

	return nil
}

// Get retrieves the first value associated with the given key.
// If there are no values associated with the key, Get returns
// the empty string. To access multiple values, use the map
// directly.
// func (c Map) Get(key ...common.Key) interface{} {
// 	if len(key) == 0 {
// 		return c
// 	}

// 	keys := keysToString(key)

// 	if c == nil {
// 		return nil
// 	}

// 	if len(keys) == 0 {
// 		return c
// 	}

// 	// We handle if we have a separator defined
// 	k := keys[0]
// 	keys = keys[1:]

// 	v, ok := c[k]
// 	if !ok {
// 		return nil
// 	}

// 	if len(keys) == 0 {
// 		return v
// 	}

// 	switch m := v.(type) {
// 	case Map:
// 		return m.Get(keys)
// 	case map[string]interface{}:
// 		return Map(m).Get(keys)
// 	}

// 	return v
// }

// func (c Map) Map(key common.Key) map[string]interface{} {
// 	val := c.Get(key)

// 	if m, ok := val.(map[string]interface{}); ok {
// 		return m
// 	}

// 	if s, ok := val.(string); ok {
// 		var m map[string]interface{}
// 		if err := json.Unmarshal([]byte(s), &m); err == nil {
// 			return m
// 		}
// 	}

// 	return nil
// }

// func (c Map) Array(key common.Key) common.Scanner {
// 	var a Array

// 	val := c.Get(key)

// 	m, ok := val.([]interface{})
// 	if !ok {
// 		a = []interface{}{}
// 	} else {
// 		a = m
// 	}

// 	return a
// }

// func (c Map) StringMap(key common.Key) map[string]string {
// 	return cast.ToStringMapString(c.Get(key))
// }

// func (c Map) String(key common.Key, def ...string) string {
// 	if q := c.Get(key); q != nil {
// 		switch v := q.(type) {
// 		case []string:
// 			if b, err := json.Marshal(v); err == nil {
// 				return string(b)
// 			}

// 			if len(def) > 0 {
// 				return "[" + strings.Join(def, ",") + "]"
// 			}

// 			return "[]"
// 		case string:
// 			return v
// 		}
// 	}

// 	if len(def) > 1 {
// 		return "[" + strings.Join(def, ",") + "]"
// 	}

// 	if len(def) > 0 {
// 		return def[0]
// 	}

// 	return ""
// }

// func (c Map) StringArray(key common.Key, def ...[]string) []string {
// 	val := c.Get(key)

// 	switch v := val.(type) {
// 	case []string:
// 		return v
// 	case string:
// 		var a []string
// 		if err := json.Unmarshal([]byte(v), &a); err == nil {
// 			return a
// 		}
// 	case []interface{}:
// 		var a []string
// 		for _, d := range v {
// 			a = append(a, fmt.Sprintf("%s", d))
// 		}
// 		return a
// 	}

// 	if len(def) > 0 {
// 		return def[0]
// 	}

// 	return []string{}
// }

// func (c Map) Duration(key common.Key, def ...string) time.Duration {
// 	val := c.String(key, "")

// 	d, err := time.ParseDuration(val)
// 	if err != nil {
// 		if len(def) > 0 {
// 			d, err := time.ParseDuration(def[0])
// 			if err != nil {
// 				return 0
// 			}

// 			return d
// 		}
// 	}

// 	return d
// }

// // Database returns the driver and dsn in that order for the given key
// func (c Map) Database(key common.Key, refs map[string]common.Database, def ...common.Database) (common.Database, error) {
// 	val := c.Get(key)

// 	switch v := val.(type) {
// 	case string:
// 		if vv, ok := refs[v]; ok {
// 			return vv, nil
// 		}
// 	default:
// 		m, err := cast.ToStringMapStringE(c.Get(key))
// 		if err != nil {
// 			break
// 		}

// 		return &Database{
// 			Driver: m["driver"],
// 			DSN:    m["dsn"],
// 		}, nil
// 	}

// 	if len(def) > 0 {
// 		return def[0], nil
// 	}

// 	return nil, fmt.Errorf("Could not find database")
// }

// func (c Map) Bool(key common.Key, def ...bool) bool {

// 	if c.Get(key) != nil {
// 		if b, ok := c.Get(key).(bool); ok {
// 			return b
// 		}
// 		if s, ok := c.Get(key).(string); ok {
// 			if val, e := strconv.ParseBool(s); e == nil {
// 				return val
// 			}
// 		}
// 	}

// 	if len(def) > 0 {
// 		return def[0]
// 	}
// 	return false
// }

// // Int retrieves the value at the given key if it exists and
// // performs best effort to cast it as an int.
// // If no such key exists or if it cannot be cast as an int,
// // it returns the default value if defined and 0 otherwise.
// func (c Map) Int(key common.Key, def ...int) int {
// 	switch v := c.Get(key).(type) {
// 	case int:
// 		return v
// 	case string:
// 		if p, err := strconv.Atoi(v); err != nil {
// 			break
// 		} else {
// 			return p
// 		}
// 	case float64:
// 		return int(v)
// 	}

// 	if len(def) > 0 {
// 		return def[0]
// 	}

// 	return 0
// }

// // Int64 retrieves the value at the given key if it exists and
// // performs best effort to cast it as an int64.
// // If no such key exists or if it cannot be cast as an int64,
// // it returns the default value if defined and 0 otherwise.
// func (c Map) Int64(key common.Key, defaultValue ...int64) int64 {
// 	switch v := c.Get(key).(type) {
// 	case int64:
// 		return v
// 	case int:
// 		return int64(v)
// 	case int16:
// 		return int64(v)
// 	case int32:
// 		return int64(v)
// 	case string:
// 		if p, err := strconv.ParseInt(v, 10, 64); err != nil {
// 			break
// 		} else {
// 			return p
// 		}
// 	case float64:
// 		return int64(v)
// 	}

// 	if len(defaultValue) > 0 {
// 		return defaultValue[0]
// 	}
// 	return int64(0)
// }

func (c Map) Scan(val interface{}) error {
	if c.IsEmpty() {
		return nil
	}

	jsonStr, err := json.Marshal(c)
	if err != nil {
		return err
	}

	switch v := val.(type) {
	case proto.Message:
		err = (&jsonpb.Unmarshaler{AllowUnknownFields: true}).Unmarshal(bytes.NewReader(jsonStr), v)
	default:
		err = json.Unmarshal(jsonStr, v)
	}

	return err
}

// func (c Map) Bytes(key common.Key, def ...[]byte) []byte {
// 	str := c.String(key)
// 	return []byte(str)
// }

func (c Map) Values(k ...common.Key) common.ConfigValues {
	keys := keysToString(k...)

	if len(keys) == 0 {
		return c
	}

	v, ok := c[keys[0]]
	if !ok {
		return (*Value)(nil)
	}

	if m, err := cast.ToStringMapE(v); err == nil {
		return Map(m).Values(keys[1:])
	}

	if a, err := cast.ToSliceE(v); err == nil {
		return Array(a).Values(keys[1:])
	}

	return (&Value{v, c, keys[0]}).Values(keys[1:])
}

func (c Map) IsEmpty() bool {
	return len(c) == 0
}

// Set sets the key to value. It replaces any existing
// values.
// func (c Map) Set(key common.Key, value interface{}) error {
// 	keys := keysToString(key)
// 	pkeys := keys[0 : len(keys)-1]
// 	tkey := keys[len(keys)-1]

// 	// Retrieving existing lowest index in map
// 	var i = 0
// 	for i = 0; i < len(pkeys); i++ {
// 		if c.Get(pkeys[0:i+1]) == nil {
// 			break
// 		}
// 	}

// 	cursor := c.Get(pkeys[0:i])

// 	mcursor, ok := cursor.(Map)
// 	if !ok {
// 		return fmt.Errorf("Existing index is not a map")
// 	}

// 	// Building remaining key with an empty value
// 	var j = 0
// 	for j = i; j < len(pkeys); j++ {
// 		mcursor[pkeys[j]] = map[string]interface{}{}
// 		mcursor = mcursor[pkeys[j]].(map[string]interface{})
// 	}

// 	// Finally set the target key
// 	mcursor[tkey] = value

// 	return nil
// }

// Del deletes the values associated with key.
// func (c Map) Del(key common.Key) error {
// 	keys := keysToString(key)
// 	pkeys := keys[0 : len(keys)-1]
// 	tkey := keys[len(keys)-1]

// 	cursor := c.Get(pkeys)
// 	mcursor, ok := cursor.(map[string]interface{})
// 	if !ok {
// 		return fmt.Errorf("Existing index is not a map")
// 	}

// 	delete(mcursor, tkey)

// 	return nil
// }
