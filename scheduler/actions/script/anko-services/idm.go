package anko_services

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/golang/protobuf/jsonpb"
	"github.com/golang/protobuf/ptypes"
	"github.com/golang/protobuf/ptypes/any"
	"github.com/pborman/uuid"

	"github.com/pydio/cells/common"
	"github.com/pydio/cells/common/log"
	"github.com/pydio/cells/common/proto/idm"
	"github.com/pydio/cells/common/proto/tree"
	"github.com/pydio/cells/common/registry"
	service "github.com/pydio/cells/common/service/proto"
)

type IdmService struct {
	ctx context.Context
}

func NewIdmService(c context.Context) *IdmService {
	return &IdmService{ctx: c}
}

// ListWorkspaces performs a ws search, unmarshalling its first parameter
// as JSONPB-encoded WorkspaceSingleQuery
func (srv *IdmService) ListWorkspaces(m map[string]interface{}) (wss []*idm.Workspace, e error) {
	enc, er := json.Marshal(m)
	if er != nil {
		e = er
		return
	}
	var singleQ idm.WorkspaceSingleQuery
	req := &idm.SearchWorkspaceRequest{}
	if e = jsonpb.UnmarshalString(string(enc), &singleQ); e != nil {
		return
	}
	an, _ := ptypes.MarshalAny(&singleQ)
	req.Query = &service.Query{SubQueries: []*any.Any{an}}
	cl := idm.NewWorkspaceServiceClient(registry.GetClient(common.SERVICE_WORKSPACE))
	s, err := cl.SearchWorkspace(srv.ctx, req)
	if err != nil {
		e = err
		return
	}
	defer s.Close()
	for {
		r, e := s.Recv()
		if e != nil {
			break
		}
		wss = append(wss, r.Workspace)
	}
	return
}

// GetOrCreateWorkspaceOnNode look for a workspace that has this node as unique root, and creates it otherwise.
func (srv *IdmService) GetOrCreateWorkspaceOnNode(node *tree.Node, scope string, createLabel string) (*idm.Workspace, error) {
	// Load ACLs on this node
	wsScope := idm.WorkspaceScope_ANY
	if i, o := idm.WorkspaceScope_value[scope]; o {
		wsScope = idm.WorkspaceScope(i)
	}
	aclClient := idm.NewACLServiceClient(registry.GetClient(common.SERVICE_ACL))
	aclQ, _ := ptypes.MarshalAny(&idm.ACLSingleQuery{NodeIDs: []string{node.Uuid}})
	aclA, _ := ptypes.MarshalAny(&idm.ACLSingleQuery{Actions: []*idm.ACLAction{{Name: "workspace-path"}}})
	s, e := aclClient.SearchACL(srv.ctx, &idm.SearchACLRequest{
		Query: &service.Query{SubQueries: []*any.Any{aclQ, aclA}, Operation: service.OperationType_AND},
	})
	if e != nil {
		return nil, e
	}
	defer s.Close()
	wss := make(map[string][]*idm.ACL)
	for {
		r, er := s.Recv()
		if er != nil || r == nil {
			break
		}
		if r.ACL.WorkspaceID == "" {
			continue
		}
		if _, o := wss[r.ACL.WorkspaceID]; !o {
			wss[r.ACL.WorkspaceID] = []*idm.ACL{}
		}
		wss[r.ACL.WorkspaceID] = append(wss[r.ACL.WorkspaceID], r.ACL)
	}
	var ids []string
	for id, acls := range wss {
		if len(acls) > 1 {
			log.Logger(srv.ctx).Warn("found workspace with multiple roots! cannot use that one as it may open access to other nodes")
		} else {
			ids = append(ids, id)
		}
	}
	wsClient := idm.NewWorkspaceServiceClient(registry.GetClient(common.SERVICE_WORKSPACE))
	if len(ids) == 0 {
		// CREATE
		createScope := idm.WorkspaceScope_ADMIN
		if wsScope != idm.WorkspaceScope_ANY {
			createScope = wsScope
		}
		builder := service.NewResourcePoliciesBuilder()
		builder.WithProfileWrite(common.PYDIO_PROFILE_ADMIN).WithProfileRead(common.PYDIO_PROFILE_STANDARD)
		r, e := wsClient.CreateWorkspace(srv.ctx, &idm.CreateWorkspaceRequest{Workspace: &idm.Workspace{
			UUID:        uuid.New(),
			Label:       createLabel,
			Description: "Automatically generated by scheduler action",
			Scope:       createScope,
			Policies:    builder.Policies(),
		}})
		if e != nil {
			return nil, e
		}
		// Create ACL for node root
		wsPath := node.Path
		if createScope != idm.WorkspaceScope_ADMIN {
			wsPath = "uuid:" + node.Uuid
		}
		_, er := aclClient.CreateACL(srv.ctx, &idm.CreateACLRequest{ACL: &idm.ACL{
			Action:      &idm.ACLAction{Name: "workspace-path", Value: wsPath},
			WorkspaceID: r.Workspace.UUID,
			NodeID:      node.Uuid,
		}})
		if er != nil {
			// ACL CREATION FAILED : DELETE PREVIOUSLY CREATED WORKSPACE
			delQ, _ := ptypes.MarshalAny(&idm.WorkspaceSingleQuery{Uuid: r.Workspace.UUID})
			wsClient.DeleteWorkspace(srv.ctx, &idm.DeleteWorkspaceRequest{Query: &service.Query{SubQueries: []*any.Any{delQ}}})
			return nil, er
		}
		return r.Workspace, nil
	} else {
		// Find workspaces by UUID
		var wq []*any.Any
		for _, wsId := range ids {
			q, _ := ptypes.MarshalAny(&idm.WorkspaceSingleQuery{Uuid: wsId, Scope: wsScope})
			wq = append(wq, q)
		}
		// Pick the first one
		st, er := wsClient.SearchWorkspace(srv.ctx, &idm.SearchWorkspaceRequest{Query: &service.Query{
			SubQueries: wq, Operation: service.OperationType_OR, Offset: 0, Limit: 1,
		}})
		if er != nil {
			return nil, er
		}
		defer st.Close()
		for {
			resp, e := st.Recv()
			if e != nil || resp == nil {
				break
			}
			// Return first result
			return resp.Workspace, nil
		}
		return nil, fmt.Errorf("no workspace found")
	}
}

// MakeACL prepares an ACL
func (srv *IdmService) MakeACL(nodeUuid, roleUuid, wsUuid, actionName, actionValue string) *idm.ACL {
	return &idm.ACL{
		Action:      &idm.ACLAction{Name: actionName, Value: actionValue},
		RoleID:      roleUuid,
		WorkspaceID: wsUuid,
		NodeID:      nodeUuid,
	}
}
